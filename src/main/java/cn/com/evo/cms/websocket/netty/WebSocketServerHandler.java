package cn.com.evo.cms.websocket.netty;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelFutureListener;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.channel.group.ChannelGroup;import io.netty.channel.group.DefaultChannelGroup;import io.netty.handler.codec.http.*;import io.netty.handler.codec.http.websocketx.*;import io.netty.util.CharsetUtil;import io.netty.util.concurrent.GlobalEventExecutor;/** * @Description: 自定义处理类 * @author: lu.xin * @create: 2019-04-22 10:24 AM **/public class WebSocketServerHandler extends SimpleChannelInboundHandler<Object> {    private static final ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);    private static final String WEBSOCKET_PATH = "/websocket";    private WebSocketServerHandshaker handshaker;    /**     * 握手建立     *     * @param ctx     * @throws Exception     */    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        super.channelActive(ctx);        channels.add(ctx.channel());    }    /**     * 握手取消     *     * @param ctx     * @throws Exception     */    @Override    public void channelInactive(ChannelHandlerContext ctx) throws Exception {        super.channelInactive(ctx);        channels.remove(ctx.channel());    }    /**     * 处理客户端发送过来的消息     *     * @param ctx     * @param msg     */    @Override    public void channelRead0(ChannelHandlerContext ctx, Object msg) {        if (msg instanceof FullHttpRequest) {            // http请求，进行http操作            handleHttpRequest(ctx, (FullHttpRequest) msg);        } else if (msg instanceof WebSocketFrame) {            // WebSocket请求，进行WebSocket操作            handleWebSocketFrame(ctx, (WebSocketFrame) msg);        }    }    @Override    public void channelReadComplete(ChannelHandlerContext ctx) {        ctx.flush();    }    /**     * 处理http请求     *     * @param ctx     * @param req     */    private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) {        // 处理 bad request.        if (!req.decoderResult().isSuccess()) {            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST));            return;        }        // 只允许 GET 方法.        if (req.method() != HttpMethod.GET) {            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.FORBIDDEN));            return;        }        // 握手        String path = getWebSocketLocation(req);        WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory(path, null, true, 5 * 1024 * 1024);        handshaker = wsFactory.newHandshaker(req);        if (handshaker == null) {            WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());        } else {            handshaker.handshake(ctx.channel(), req);        }    }    /**     * 处理WebSocket请求     *     * @param ctx     * @param frame     */    private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {        // 判断是否是关闭链路的指令        if (frame instanceof CloseWebSocketFrame) {            handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain());            return;        }        // 判断是否是Ping消息        if (frame instanceof PingWebSocketFrame) {            ctx.write(new PongWebSocketFrame(frame.content().retain()));            return;        }        // 文本消息，不支持二进制消息        if (frame instanceof TextWebSocketFrame) {            System.out.println(ctx.name() + "\t" + ((TextWebSocketFrame) frame).text());            // 广播给所有客户端//            channels.writeAndFlush(new TextWebSocketFrame(((TextWebSocketFrame) frame).text()));            // 广播给指定用户            ctx.write(new TextWebSocketFrame(((TextWebSocketFrame) frame).text()));            return;        }        if (frame instanceof BinaryWebSocketFrame) {            ctx.write(frame.retain());        }    }    private static void sendHttpResponse(ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse res) {        if (res.status().code() != HttpResponseStatus.OK.code()) {            ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(), CharsetUtil.UTF_8);            res.content().writeBytes(buf);            buf.release();            HttpUtil.setContentLength(res, res.content().readableBytes());        }        ChannelFuture f = ctx.channel().writeAndFlush(res);        if (!HttpUtil.isKeepAlive(req) || res.status().code() != HttpResponseStatus.OK.code()) {            f.addListener(ChannelFutureListener.CLOSE);        }    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {        cause.printStackTrace();        ctx.close();    }    private static String getWebSocketLocation(FullHttpRequest req) {        String location = req.headers().get(HttpHeaderNames.HOST) + WEBSOCKET_PATH;        return "ws://" + location;    }}