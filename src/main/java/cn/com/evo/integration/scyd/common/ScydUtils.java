package cn.com.evo.integration.scyd.common;import cn.com.evo.admin.manage.domain.entity.Province;import cn.com.evo.cms.domain.entity.cms.Picture;import cn.com.evo.cms.domain.entity.cms.Video;import cn.com.evo.integration.chongqing.common.CQConstantEnum;import cn.com.evo.integration.common.ConstantFactory;import com.frameworks.utils.FileUtils;import com.google.common.collect.Lists;import com.google.common.collect.Maps;import org.apache.commons.codec.digest.DigestUtils;import org.apache.commons.lang3.StringUtils;import org.apache.commons.net.ftp.FTPClient;import org.apache.commons.net.ftp.FTPReply;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.*;import java.net.SocketException;import java.security.SecureRandom;import java.util.*;/** * @Description: 处理xml文件中各种url地址工具类 * @author: lu.xin * @create: 2019-03-28 9:55 AM **/public class ScydUtils {    /**     * 根据四川移动省网业务逻辑     * 转换图片list     * 1. 加入图片ftp访问地址信息     * 2. 返回完整ftp访问地址     *     * @param pictures     * @return     */    public static List<String> createPictureFtpUrls(List<Picture> pictures, Province province) {        List<String> pictureUrls = Lists.newArrayList();        for (Picture picture : pictures) {            String fileName = picture.getFileName();            if (StringUtils.isBlank(province.getFtpUser()) ||                    StringUtils.isBlank(province.getFtpPassword()) ||                    StringUtils.isBlank(province.getFtpUrl()) ||                    StringUtils.isBlank(province.getFtpPort())) {                throw new RuntimeException("省网FTP相关信息配置不全!!!");            }            // 根据接口需要拼装url            String pictureFtpUrl = province.getImageHost() + fileName;            pictureUrls.add(pictureFtpUrl);        }        return pictureUrls;    }    /**     * 生成xml的ftp地址     *     * @param xmlUrl     * @param province     * @return     */    public static String createXmlFtpUrl(String xmlUrl, Province province) {        if (StringUtils.isBlank(province.getFtpUser()) ||                StringUtils.isBlank(province.getFtpPassword()) ||                StringUtils.isBlank(province.getFtpUrl()) ||                StringUtils.isBlank(province.getFtpPort())) {            throw new RuntimeException("省网FTP相关信息配置不全!!!");        }        // 根据接口需要拼装url        String xmlFtpUrl = "ftp://" + province.getFtpUser() +                ":" + province.getFtpPassword() +                "@" + province.getFtpUrl() + ":" + province.getFtpPort() + "/" + getFileName(xmlUrl);        return xmlFtpUrl;    }    /**     * 根据四川移动省网业务逻辑     * 转换视频对象http访问地址     *     * @param video     * @return     */    public static String createVideoHttpUrl(Video video) {        String videoUrl = ConstantFactory.map.get(ConstantEnum.video_host.getKey()) + getFileName(video.getUrl());        return videoUrl;    }    /**     * 获取文件名     *     * @param url     * @return     */    private static String getFileName(String url) {        Integer index = url.lastIndexOf("/");        return url.substring(index + 1, url.length());    }    /**     * 获取签名     *     * @param map     * @param privateKey     * @return     */    public static String getSign(Map<String, String> map, String privateKey) {        ArrayList<String> list = new ArrayList<String>();        for (Map.Entry<String, String> entry : map.entrySet()) {            if (StringUtils.isNotBlank(entry.getValue())) {                list.add(entry.getKey() + "=" + entry.getValue() + "&");            }        }        int size = list.size();        String[] arrayToSort = list.toArray(new String[size]);        Arrays.sort(arrayToSort, String.CASE_INSENSITIVE_ORDER);        StringBuilder sb = new StringBuilder();        for (int i = 0; i < size; i++) {            sb.append(arrayToSort[i]);        }        String result = sb.toString();        result += "key=" + privateKey;        result = DigestUtils.md5Hex(result).toUpperCase();        return result;    }    /**     * 检测签名     *     * @param map     * @param privateKey     * @return     */    public static boolean checkSign(Map<String, String> map, String privateKey) {        String signFromAPIResponse = map.get("sign");        if (signFromAPIResponse == "" || signFromAPIResponse == null) {            return false;        }        //清掉返回数据对象里面的Sign数据（不能把这个数据也加进去进行签名），然后用签名算法进行签名        map.remove("sign");        //将API返回的数据根据用签名算法进行计算新的签名，用来跟API返回的签名进行比较        String signForAPIResponse = getSign(map, privateKey);        if (!signForAPIResponse.equals(signFromAPIResponse)) {            //签名验不过，表示这个API返回的数据有可能已经被篡改了            return false;        }        return true;    }    /**     * 移动文件至指定目录     *     * @param beforePath     * @param afterPath     * @throws IOException     * @throws InterruptedException     */    public static void moveFile(String beforePath, String afterPath) throws IOException, InterruptedException {        String command1 = "chmod 777 " + beforePath;        Runtime.getRuntime().exec(command1).waitFor();//        String command2 = "mv -f " + beforePath + " " + afterPath;//        Runtime.getRuntime().exec(command2).waitFor();    }    /**     * 创建6位随机数     *     * @return     */    public static String createSixBitRandomNum() {        try {            SecureRandom random = SecureRandom.getInstance("SHA1PRNG");            Integer randNum = random.nextInt(1000000);            String temp = randNum.toString();            StringBuilder buwei = new StringBuilder();            if (temp.length() < 6) {                int length = 6 - temp.length();                for (int i = 0; i < length; i++) {                    buwei.append(0);                }            }            buwei.append(temp);            return buwei.toString();        } catch (Exception e) {            throw new RuntimeException("创建6位随机数异常!!!" + e.getMessage(), e);        }    }    /**     * 写本地xml文件     *     * @param filePath     * @param content     */    public static void write(String filePath, String content) {        BufferedWriter out = null;        try {            File file = new File(filePath);            if (file.exists()) {                file.delete();            }            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filePath, true)));            out.write(content);        } catch (Exception e) {            throw new RuntimeException("写本地xml文件异常" + e.getMessage(), e);        } finally {            try {                if (out != null) {                    out.close();                }            } catch (IOException e) {                throw new RuntimeException("关闭本地xml文件流异常" + e.getMessage(), e);            }        }    }    /**     * 创建本地xml文件，并返回xml的ftp路径     *     * @param contentId 内容id     * @param xmlStr    xml内容     * @param province  省网配置     * @return ftp路径     */    public static String createLoaclXML(String contentId, String xmlStr, Province province) throws IOException, InterruptedException {        // 创建本地xml存储目录        String localDir = "/home/xml/";        FileUtils.mkdir(localDir);        String localPath = localDir + contentId + ".xml";        // 写xml文件        write(localPath, xmlStr);        // 移动xml文件        ScydUtils.moveFile(localPath, ConstantFactory.map.get(CQConstantEnum.ftp_xml_path.getKey()) + contentId + ".xml");        // xml的ftp访问路径        String xmlUrl = "ftp://" + province.getFtpUser() +                ":" + province.getFtpPassword() +                "@" + province.getFtpUrl() + ":" + province.getFtpPort() + "/" + contentId + ".xml";        return xmlUrl;    }    /**     * 从ftp下载文件     *     * @param url     * @param targetDir     * @return     */    public static String downFtpFile(String url, String targetDir) {        String[] temps = url.replace("ftp://", "").split("/");        String[] temps2 = temps[0].split("@");        String[] temps3 = temps2[0].split(":");        String ftpHost = temps2[1].split(":")[0];        String ftpUserName = temps3[0];        String ftpPassword = temps3[1];        String ftpPort = temps2[1].split(":")[1];        String fileName = temps[1];        downloadFtpFile(ftpHost, ftpUserName, ftpPassword, Integer.valueOf(ftpPort),                "/", targetDir, fileName);        return targetDir + fileName;    }    /**     * 解析xml文件     * Document document = reader.read(new File("/Users/luxin/Desktop/20190410224511462.xml"));     *     * @param localFilePath     * @throws DocumentException     */    public static Map<String, String> transXmlData(String localFilePath) throws DocumentException {        List<Map<String, String>> list = Lists.newArrayList();        // 通过reader对象的read方法加载books.xml文件,获取docuemnt对象。        SAXReader reader = new SAXReader();        Document document = reader.read(new File(localFilePath));        // 通过document对象获取根节点bookstore        Element xml = document.getRootElement();        // 通过element对象的elementIterator方法获取迭代器        Iterator it = xml.elementIterator();        // 遍历迭代器，获取根节点中的信息（书籍）        Map<String, String> map = Maps.newHashMap();        while (it.hasNext()) {            Element reply = (Element) it.next();            Iterator itt = reply.elementIterator();            while (itt.hasNext()) {                Element property = (Element) itt.next();                if (StringUtils.isNotBlank(property.getStringValue())) {                    map.put(property.attributeValue("Name"), property.getStringValue());                }            }        }        return map;    }    public static void main(String[] args) {//        String url = "ftp://evo_ftp:Evomedia-ftp@112.18.251.71:8091/ftp/pub/xml/ff8080816a92a9b1016a92bda7730188.xml";        String url = "ftp://ftp_cp2:qWnYvp)xyhopCsR1@223.87.2.143:39/20190509173858225.xml";        String[] temps = url.replace("ftp://", "").split("/");        String[] temps2 = temps[0].split("@");        String[] temps3 = temps2[0].split(":");        String ftpHost = temps2[1].split(":")[0];        String ftpPort = temps2[1].split(":")[1];        String ftpUserName = temps3[0];        String ftpPassword = temps3[1];        String fileName = temps[1];        System.out.println("ftpHost:" + ftpHost);        System.out.println("ftpUserName:" + ftpUserName);        System.out.println("ftpPassword:" + ftpPassword);        System.out.println("ftpPort:" + ftpPort);        System.out.println("fileName:" + fileName);        //downloadFtpFile("112.18.251.71", "evo_ftp", "Evomedia-ftp",8091, "/ftp/pub/xml","/data", "ff8080816a92a9b1016a92bda7730188.xml");    }    /*     * 从FTP服务器下载文件     *     * @param ftpHost FTP IP地址     * @param ftpUserName FTP 用户名     * @param ftpPassword FTP用户名密码     * @param ftpPort FTP端口     * @param ftpPath FTP服务器中文件所在路径 格式： ftptest/aa     * @param localPath 下载到本地的位置 格式：H:/download     * @param fileName 文件名称     */    public static void downloadFtpFile(String ftpHost, String ftpUserName,                                       String ftpPassword, int ftpPort, String ftpPath, String localPath,                                       String fileName) {        FTPClient ftpClient = null;        try {            ftpClient = getFTPClient(ftpHost, ftpUserName, ftpPassword, ftpPort);            ftpClient.setControlEncoding("UTF-8"); // 中文支持            ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);            ftpClient.enterLocalPassiveMode();            ftpClient.changeWorkingDirectory(ftpPath);            File localFile = new File(localPath + File.separatorChar + fileName);            OutputStream os = new FileOutputStream(localFile);            ftpClient.retrieveFile(fileName, os);            os.close();            ftpClient.logout();        } catch (FileNotFoundException e) {            System.out.println("没有找到" + ftpPath + "文件");            e.printStackTrace();        } catch (SocketException e) {            System.out.println("连接FTP失败.");            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();            System.out.println("文件读取错误。");            e.printStackTrace();        }    }    public static FTPClient getFTPClient(String ftpHost, String ftpUserName,                                         String ftpPassword, int ftpPort) {        FTPClient ftpClient = new FTPClient();        try {            ftpClient = new FTPClient();            ftpClient.connect(ftpHost, ftpPort);// 连接FTP服务器            ftpClient.login(ftpUserName, ftpPassword);// 登陆FTP服务器            if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {                System.out.println("未连接到FTP，用户名或密码错误。");                ftpClient.disconnect();            } else {                System.out.println("FTP连接成功。");            }        } catch (SocketException e) {            e.printStackTrace();            System.out.println("FTP的IP地址可能错误，请正确配置。");        } catch (IOException e) {            e.printStackTrace();            System.out.println("FTP的端口错误,请正确配置。");        }        return ftpClient;    }}