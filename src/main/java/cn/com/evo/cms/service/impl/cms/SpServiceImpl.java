package cn.com.evo.cms.service.impl.cms;import cn.com.evo.admin.manage.domain.entity.Province;import cn.com.evo.admin.manage.service.ProvinceService;import cn.com.evo.cms.constant.ProvinceCodeEnum;import cn.com.evo.cms.domain.entity.cms.CatalogueRelation;import cn.com.evo.cms.domain.entity.cms.Column;import cn.com.evo.cms.domain.entity.cms.Content;import cn.com.evo.cms.domain.entity.cms.Video;import cn.com.evo.cms.domain.entity.total.ContentOperation;import cn.com.evo.cms.domain.enums.ContentClassifyEnum;import cn.com.evo.cms.service.cms.*;import cn.com.evo.cms.service.total.ContentOperationService;import cn.com.evo.cms.web.api.LiveApi;import cn.com.evo.integration.common.enums.ActionEnum;import cn.com.evo.integration.xjdx.XjdxContentServiceImpl;import cn.com.evo.integration.xjdx.XjdxWebServiceSDK;import cn.com.evo.integration.xjdx.common.XjdxUtils;import cn.com.evo.integration.xjdx.content.CreateXml;import cn.com.evo.integration.xjdx.content.model.Program;import cn.com.evo.provincial.service.ProvincialService;import cn.com.evo.provincial.factory.ProvincialFactory;import com.google.common.collect.Lists;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.BeanUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.web.multipart.MultipartFile;import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.stream.Collectors;/** * @Description: 省网接口实现 * @author: lu.xin * @create: 2019-03-11 11:14 AM **/@Service@Transactionalpublic class SpServiceImpl implements SpService {    @Autowired    private ProvinceService provinceService;    @Autowired    private VideoService videoService;    @Autowired    private CatalogueRelationService catalogueRelationService;    @Autowired    private ContentService contentService;    @Autowired    private ColumnService columnService;    @Autowired    private ProvincialFactory provincialFactory;    @Autowired    private ContentOperationService contentOperationService;    @Override    public void pullResource() {        //获取省网配置类        Province province = getProvince();        //获取省网操作对象        ProvincialService provincial = getProvincial(province.getCode());        //资源拉取        provincial.pull();    }    @Override    public void synMovie(String contentId, String action) {        //获取省网配置类        Province province = getProvince();        //获取省网操作对象        ProvincialService provincial = getProvincial(province.getCode());        // 同步动作枚举        ActionEnum actionEnum = ActionEnum.getByValue(action);        switch (actionEnum) {            case REGIST:                provincial.registMovie(contentId, province);                break;            case UPDATE:                provincial.updateMovie(contentId, province);                break;            case DELETE:                provincial.deleteMovie(contentId, province);                break;            default:                throw new RuntimeException("暂时不支持该操作!!!");         }    }    @Override    public void synEpisode(String contentId, String action) {        //获取省网配置类        Province province = getProvince();        //获取省网操作对象        ProvincialService provincial = getProvincial(province.getCode());        // 同步动作枚举        ActionEnum actionEnum = ActionEnum.getByValue(action);        switch (actionEnum) {            case REGIST:                provincial.registSeries(contentId, province);                break;            case UPDATE:                provincial.updateSeries(contentId, province);                break;            case DELETE:                provincial.deleteSeries(contentId, province);                break;            default:                throw new RuntimeException("暂时不支持该操作!!!");        }    }    /**     * 获取省网配置对象     * @return     */    private Province getProvince(){        Province province = provinceService.getByEnable(1);        if (province == null) {            throw new RuntimeException("没有可用的省网配置!!!");        }        return province;    }    /**     * 获取省网对象     * @param code 省网配置编码     * @return     */    private ProvincialService getProvincial(String code){        return provincialFactory.createProvincial(code);    }    @Override    public void synEpisodeChild(String contentId, String action) {        //获取省网配置类        Province province = getProvince();        //获取省网操作对象        ProvincialService provincial = getProvincial(province.getCode());        // 同步动作枚举        ActionEnum actionEnum = ActionEnum.getByValue(action);        switch (actionEnum) {            case REGIST:                provincial.registSeriesChild(contentId, province);                break;            case UPDATE:                provincial.updateSeriesChild(contentId, province);                break;            case DELETE:                provincial.deleteSeriesChild(contentId, province);                break;            default:                throw new RuntimeException("暂时不支持该操作!!!");        }    }    @Override    public void synMovies(String[] contentIds, String action) {        for (String contentId : contentIds) {            this.synMovie(contentId, action);        }    }    @Override    public void synEpisodes(String[] contentIds, String action) {        for (String contentId : contentIds) {            this.synEpisode(contentId, action);        }    }    @Override    public void synEpisodeChilds(String[] contentIds, String action) {        for (String contentId : contentIds) {            this.synEpisodeChild(contentId, action);        }    }    /**     * 数据注入     * @param catalogueRelationId     */    @Override    public void voiceSyn(String catalogueRelationId) {        //获取省网配置类        Province province = getProvince();        //获取省网操作对象        ProvincialService provincial = getProvincial(province.getCode());        //请求省网注入数据逻辑 或者音频注入        provincial.dataSyn(catalogueRelationId);    }    @Override    public Video getPlayUrl(String catalogueRelationId, Integer episodeNumber, String accesstoken, String appId, String platform) {        String childContentId = null;        CatalogueRelation catalogueRelation = catalogueRelationService.findById(catalogueRelationId);        Content content = contentService.findById(catalogueRelation.getBId());        if (ContentClassifyEnum.episode.getIndex() == content.getClassify()) {            Content child = contentService.findContentByNumber(catalogueRelationId, episodeNumber);            if (child == null) {                throw new RuntimeException("无当前子集信息");            } else {                childContentId = child.getId();            }        } else {            childContentId = content.getId();        }        return getPlayUrl(childContentId, accesstoken, appId, platform);    }    @Override    public Video getPlayUrl(String contentId, String accesstoken, String appId, String platform) {        //获取省网配置类        Province province = getProvince();        //获取省网操作对象        ProvincialService provincial = getProvincial(province.getCode());        // 获取内容全部视频        List<Video> list = videoService.findByContentId(contentId);        // 获取对应平台来源的视频list        Column app = columnService.findById(appId);        List<Video> temps = Lists.newArrayList();        if (list.size() <= 0) {            throw new RuntimeException("该内容未配置相关视频资源");        }        for (Video temp : list) {            if (StringUtils.isNotBlank(platform)) {                if (platform.equals(temp.getPlatform())) {                    temps.add(temp);                }            } else {                if (app.getPlatform().equals(temp.getPlatform())) {                    temps.add(temp);                }            }        }        return provincial.getPlayURL(accesstoken, temps, appId);    }    @Override    public void registMovieForXjdx(MultipartFile[] files) {        //获取省网配置类        Province province = getProvince();        List<Program> programs = contentService.xjdxImportFile(files);        for (Program program : programs) {            String xmlStr = "";            if("电视剧".equals(program.getContentType())){                xmlStr = CreateXml.createSeries(program);            } else {                xmlStr = CreateXml.createMovie(program);            }            String random = CreateXml.getRandom();            //写入本地文件            String localPath = XjdxUtils.createLoaclXML(random, xmlStr, province);            //上传xml文件到ftp服务器并返回ftp路径            String xmlFtpuRL = XjdxUtils.uploadXml(localPath, province);            String correlateID = CreateXml.getRandom();            XjdxWebServiceSDK.callCmd(correlateID, xmlFtpuRL);            // 保存内容采集记录表            ContentOperation contentOperation = new ContentOperation();            contentOperation.setCorrelateId(correlateID);            contentOperation.setInfo(xmlFtpuRL);            contentOperation.setStatus(1);            contentOperationService.save(contentOperation);        }    }    @Override    public void publish(String contentId) {        //判断内容状态        Content content = contentService.findById(contentId);        if(content == null){            throw new RuntimeException("当前内容不存在");        }        if(content.getSynType() != null && !content.getSynType().equals(2)){            throw new RuntimeException("该内容状态不能发布，只有注入状态是已注入时可以发布！");        }        //获取省网service        Province province = getProvince();        ProvincialService provincial = getProvincial(province.getCode());        if(StringUtils.isBlank(content.getpId()) && content.getClassify().equals(2)){            List<Content> contents = contentService.findByPIdOrderBySortAsc(content.getId());            List<String> contentIds = contents.stream().map(Content::getId).collect(Collectors.toList());            for (String id : contentIds) {                provincial.publish(id);            }        } else {            //调用局方接口进行相关操作            provincial.publish(contentId);        }    }    @Override    public void unPublish(String contentId) {        //判断内容状态        Content content = contentService.findById(contentId);        if(content == null){            throw new RuntimeException("当前内容不存在");        }        if(content.getSynType() != null && !content.getSynType().equals(4)){            throw new RuntimeException("该内容状态不能取消发布，只有已发布状态才可以取消！");        }        //获取省网service        Province province = getProvince();        ProvincialService provincial = getProvincial(province.getCode());        if(StringUtils.isBlank(content.getpId()) && content.getClassify().equals(2)){            List<Content> contents = contentService.findByPIdOrderBySortAsc(content.getId());            List<String> contentIds = contents.stream().map(Content::getId).collect(Collectors.toList());            for (String id : contentIds) {                provincial.unPublish(id);            }        } else {            //调用局方接口进行相关操作            provincial.unPublish(contentId);        }    }    @Override    public void bindProduct(String contentId, Integer type) {        //判断内容状态        Content content = contentService.findById(contentId);        if(content == null){            throw new RuntimeException("当前内容不存在");        }        if(content.getSynType() != null && !content.getSynType().equals(4)){            throw new RuntimeException("该内容状态不能绑定产品包，只有已发布状态才可以绑定！");        }        //获取省网service        Province province = getProvince();        ProvincialService provincial = getProvincial(province.getCode());        if(StringUtils.isBlank(content.getpId()) && content.getClassify().equals(2)){            List<Content> contents = contentService.findByPIdOrderBySortAsc(content.getId());            List<String> contentIds = contents.stream().map(Content::getId).collect(Collectors.toList());            for (String id : contentIds) {                provincial.bindProduct(id, type);            }        }else {            //调用局方接口进行相关操作            provincial.bindProduct(contentId, type);        }    }    @Override    public void delete(String contentId) {        //判断内容状态        Content content = contentService.findById(contentId);        if(content == null){            throw new RuntimeException("当前内容不存在");        }        if(content.getSynType() != null){            if(content.getSynType().equals(4) || content.getSynType().equals(0) || content.getSynType().equals(1)) {                throw new RuntimeException("该内容状态不能删除，只有注入失败或已注入的视频可以删除！");            }        }        //获取省网service        Province province = getProvince();        ProvincialService provincial = getProvincial(province.getCode());        //判断id是子集还是父级        if(StringUtils.isBlank(content.getpId()) && content.getClassify().equals(2)){            System.out.println("进入通过父id删除子集逻辑");            List<Content> contents = contentService.findByPIdOrderBySortAsc(content.getId());            System.out.println(contents.size());            List<String> contentIds = contents.stream().map(Content::getId).collect(Collectors.toList());            for (String id : contentIds) {                provincial.deleteAsset(id);            }            //判断子集状态全部为已注入的话。就修改剧头状态            List<Content> ckContents = contentService.findByPIdAndSynType(content.getId(), 0);            if(ckContents.size() == content.getSumNum()){                content.setSynType(0);                contentService.update(content);            }        } else {            //调用局方接口进行相关操作            provincial.deleteAsset(contentId);        }    }    @Override    public void publishs(String[] contentIds) {        for (String contentId : contentIds) {            publish(contentId);        }    }    @Override    public void unPublishs(String[] contentIds) {        for (String contentId : contentIds) {            unPublish(contentId);        }    }    @Override    public void bindProducts(String[] contentIds, Integer type) {        for (String contentId : contentIds) {            bindProduct(contentId, type);        }    }    @Override    public void deletes(String[] contentIds) {        for (String contentId : contentIds) {            delete(contentId);        }    }}